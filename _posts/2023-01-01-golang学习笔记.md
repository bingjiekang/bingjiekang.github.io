---
title: "golang学习笔记"
layout: post
date: 2023-01-01
image: /assets/images/markdown.jpg
headerImage: false
tag:
- golang
category: golang
---

##	golang学习笔记  

1. go version 查看go的版本号  
2. go env 查看go的环境
3. 先go build xx.go 然后再./xx就可以输出 先编译在运行 或者go run xx.go 直接运行   
4. 先编译再运行：优点：编译出的可执行文件可以再各个终端上运行，即使没有安装go环境，依然可以运行。原因：编译后，将代码依靠的库文件一起打包到编译好的文件里，所以可以直接运行，并且代码的容量也会变大   
5. go build -o xxx xx.go 将编译出的文件文件名变为xxx    
6. 从main()开始执行，导入的包和使用的变量，如果不使用就会报错不能编译   
7. gofmt -w xx.go 格式化演示 类似cat   
8. golang全部使用utf-8编码，不会有中文乱码，常量用const修饰，定义的时候就必须赋值，a=iota则a为0 ,每使用一个iota，iota的值就会加1  
9. golang 英文字母1个字节（byte可以用来表示一个字节），中文三个字节   
10. bool类型只能用false和true 不能用0和1表示   
11. golang中字符串是不可改变的！一旦赋值就不可变   
12. ``反引号，可以输出一段话类似python的""" """   
13. 字符串拼接 加号不能开头，要放在末尾（如果一行太多），原因默认会在一行末尾加上；   
14. map返回两个参数 第一个是value，第二个是 是否存在所找key if _,ok := HashMap[target-v];ok 如果true的话就执行  
15. 数据类型：int、float、string、bool、数组、slice切片、map、指针、结构体、channel管道。  
16. Print输出无换行、Println输出有换行、Printf是格式化输出（默认无换行，如果有需要，需要自己加）、Sprintf是格式化传入的数据并赋给变量，终端不显示。Scanf是格式化输入，Scanln直接输入，fmt.Scanln(&nm)获取一行的 fmt.Scanf()格式化获取内容（空格隔开） 获取键盘输入。        
17. golang所有数据类型的转换必须是强制转换，不能自动转换   
18. strconv 函数 可以将其他数据类型转为string类型，Formatint将整数转为其他进制数字，Formatfloat，Formatbool，ParseBool字符串转为bool，ParseXX => ParseInt,ParseFloat   
19. var ptr *int = &num ptr存的是num的地址  
20. 变量、函数名，首字母大写才能被其他包访问 首字母大写是共有的，首字母小写是私有的   
21. %b 二进制输出 0开头 是8进制 0x开头是16进制   
22. math下有一个rand包 rand.Intn(n)生成一个0-n的伪随机数，需要先设置一个随机种子，rand.Seed(time.Now().Unix())根据秒数变化 1970年0：0 Seed(time.Now().UnixNano)根据纳秒变化。   
23. lable2：外面循环 内部循环 lable1： （break lable2） 退出最外层 continue也可以跳到指定标签。   
24. goto lablex ，label ：xxx 可以使用但不建议，因为会导致程序执行顺序混乱 跳转执行 中间的代码执行不了  
25. 每个包对应一个文件夹，引用的时候是包名加文件  package 包名 （打包包名）  
26. 包的引用从GOPATH下的src开始找 所以包名路径要从src下开始   
27. 别名 xxx(引入包名） 重命名 将xxx命名为其他别名，原来包名不能再使用   
28. go build -o 重命名 xx/xx/xx/xx/main.go 编译 成重命名 可以直接运行 在不同设备上 只有当package main时才可以打包 这时他会把其他需要的文件一起打包到里面   
29. go函数不支持函数重载 不能同一个函数名有不同参数 生成不同的函数  即函数名不能重复 跟返回值和形参类型无关   
30. 函数是一种变量 可以将函数赋值给变量 可以通过变量名使用 函数本身也可以作为形参传入   
31. 函数支持对返回值命名 func xx (num int,sun int) (adnm int,subnm int) return 就不用再加其他东西   
32. golang 支持可变参数 func sum (nm int, arg... int) int  arg是切片(名字可以是其他，...三个点是关键），可以通过下标访问对应的数据例如：arg[0],arg[1]    
33. switch 后的数据类型和case的数据类型需要一样 case后面可以有多个表达式和switch后的表达式匹配 在case语句中 输入fallthrough 可以穿透下一层 x.type()和x = interface{}和switch配合可以看到x空接口指向的类型    
34. init函数在main函数前执行，每个函数都有一个init函数(初始化函数) 变量定义->init->main函数  
35. 匿名函数，一般调用一次，可以使用匿名函数，1、定义时，直接使用，只能调用一次  res := func (a int,b int)  int{xxxx}(a,b)。2、匿名函数赋给变量，调用变量可以使用函数   
36. （在一个函数内）闭包是由函数和引用到的变量构成的，在这个闭包里，变量只声明一次，不会重复声明，重复调用闭包会重复更新数据 闭包相当于类   
37. 函数中的defer(延时机制） 在函数执行完毕后，快速释放所有资源。 defer 后面的语句，会进入一个单独的栈（先入后出）同时会将对应的变量数据同时拷贝进栈(深拷贝) 待函数内其他语句执行完后（return 后）【即函数执行完毕后再执行】，再从后往前一个个出栈，弹出对应语句。创建资源后，后面加上defer用于关闭资源， 可以在函数结束后再释放资源，函数内部的资源依然可以继续使用资源    
38. 值传递（深拷贝）基本数据类型：int，float，bool，string，数组，结构体，引用传递（浅拷贝）更快：指针，切片slice、map、管道chan，interface等都是引用类型   
39.   内置函数 len、nm = new("指针类型")分配类型，主要分配值类型，nm默认为0，new的两个作用，分配一个空间用来存储值，再分配一个空间用来存储指向值的指针    
40. go中错误处理机制：defer、recover、panic  defer:=func(){err = recover()  if err!=nil{ fmt.Println(err)}} ()定义一个匿名函数，recover()会接受报错    
41. err = errors.New("自定义错误")  panic(err) 如果出错，则终止返回自定义错误并退出     
42. 数组是相同类型的集合，大小确定后不能超出范围，不能动态变化 切片：动态变化的数组，slice是数组的引用。var 切片名 []类型  []里不需要写大小，（引用类型，由三部分组成，头指针指向地址，长度，容量）  
43. cap()查看容量，能存储的最大范围   
44. 切片的使用方式：1、定义一个切片，让切片引用指定数组。make创建切片，var xx []类型 = make([]类型，大小，容量)，对于切片，必须make后才能使用3、定义切片时，直接赋值，var xx []类型 = []类型 {数据值}  
45. 使用make来创建slice，map，chanel   
46. 切片可以用append进行动态追加，slice2 = append(slice2,待追加的数据)append后必须重新赋值，它并不改变自身数据，（先创建新的数组【将待添加的数据和原来的数据都加到新数组里】，然后再用新的切片引用） ,追加切片：name = append(name,name1...),只能追加切片，不能是数组，必须加上...   
47. 