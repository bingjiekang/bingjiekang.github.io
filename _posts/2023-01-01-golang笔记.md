---
title: "记录golang一些方法"
layout: post
date: 2023-01-01
image: /assets/images/markdown.jpg
headerImage: false
tag:
- 笔记
category: 笔记
---

##	golang笔记记录  

	1、go version 查看go语言版本号  
	
	2、go env 查看go的环境
	
	3、运行目录 GOPROJECT/src/go_code/project01/main/xx.go
	
	4、先go build xx.go 然后再./xx就可以输出 先编译在运行 或者go run xx.go 直接运行  
	
	5、先编译再运行：优点：编译出的可执行文件可以再各个终端上运行，即使没有安装go环境，依然可以运行。原因：编译后，将代码依靠的库文件一起打包到编译好的文件里，所以可以直接运行，并且代码的容量也会变大  
	
	6、go build -o xxx xx.go 将编译出的文件文件名变为xxx  
	
	7、从main()开始执行，导入的包和使用的变量，如果不使用就会报错不能编译  
	
	8、gofmt -w xx.go 格式化演示 类似cat  
	
	9、var 变量名 变量类型  例如：var i （int） = 8 即i =8,或者 i:=8也可以定义并赋值，i=8是赋值（i在此前必须被声明过才能用）有var无：  
	
	10、fmt里的Printf格式化输出中%T 可以对应显示数据类型，unsafe.Sizeof(x) 显示x占用的字节数。  
	
	11、golang全部使用utf-8编码，不会有中文乱码
	
	12、golang 英文字母1个字节（byte可以用来表示一个字节），中文三个字节  
	
	13、bool类型只能用false和true 不能用0和1表示  
	
	14、golang中字符串是不可改变的！一旦赋值就不可变
	
	15、``反引号，可以输出一段话类似python的""" """
	
	16、字符串拼接 加号不能开头，要放在末尾（如果一行太多），原因默认会在一行末尾加上；  
	
	17、golang的所有基本类型 默认都为0，或空字符或false  
	
	18、Printf格式化输出中，%v按照原始数据输出，整数相除默认保存整数    
	
	19、golang所有数据类型的转换必须是强制转换，不能自动转换   
	
	20、基本类型转string smt.Sprintf()输出，string类型接收  
	
	21、strconv 函数 可以将其他数据类型转为string类型，Formatint将整数转为其他进制数字，Formatfloat，Formatbool，ParseBool字符串转为bool，ParseXX => ParseInt,ParseFloat  
	
	22、_ 下划线 代表忽略  
	
	23、var ptr *int = &num ptr存的是num的地址  
	
	24、变量、函数名，首字母大写才能被其他包访问 首字母大写是共有的，首字母小写是私有的  
	
	25、i++,i--只能独立使用 不能和其他的在一行 没有++i和--i  
	
	26、fmt.Scanln(&nm)获取一行的 fmt.Scanf()格式化获取内容（空格隔开） 获取键盘输入  
	
	27、%b 二进制输出 0开头 是8进制 0x开头是16进制  
	
	28、math下有一个rand包 rand.Intn(n)生成一个0-n的伪随机数，需要先设置一个随机种子，rand.Seed(time.Now().Unix())根据秒数变化 1970年0：0 Seed(time.Now().UnixNano)根据纳秒变化。  
	
	29、lable2：外面循环 内部循环 lable1： （break lable2） 退出最外层 continue也可以跳到指定标签。  
	
	30、goto lablex   label ：xxx 可以使用但不建议，因为会导致程序执行顺序混乱 跳转执行 中间的代码执行不了  
	
	31、func  函数名（形参）（返回的值）{}   
	
	32、每个包对应一个文件夹，引用的时候是包名加文件  package 包名 （打包包名）  
	
	33、包的引用冲GOPATH下的src开始找 所以包名路径要从src下开始  
	
	34、别名 xxx(引入包名） 重命名 将xxx命名为其他别名，原来包名不能再使用  
	
	35、go build -o 重命名 xx/xx/xx/xx/main.go 编译 成重命名 可以直接运行 在不同设备上 只有当package main时才可以打包 这时他会把其他需要的文件一起打包到里面  
	
	36、go函数不支持函数重载 不能同一个函数名有不同参数 生成不同的函数  即函数名不能重复 跟返回值和形参类型无关  
	
	37、函数是一种变量 可以将函数赋值给变量 可以通过变量名使用    
	
	38、函数本身也可以作为形参传入  
	
	39、golang支持自定义类型名 和c一样 type 命名 类型 即（命名和类型一样）定义类型时可以通过重命名的方式应用和定义（type myint int） 或者（type MyfuncType func（int,int）int) myint和int作用几乎一样，MyfuncType和func (int,int) int 一样都可以作为参数传给函数当做形参  
	
	40、函数支持对返回值命名 func xx (num int,sun int) (adnm int,subnm int) return 就不用再加其他东西  
	
	41 golang 支持可变参数 func sum (nm int, arg... int) int  arg是切片(名字可以是其他，...三个点是关键），可以通过下标访问对应的数据例如：arg[0],arg[1]  
	
	42、 switch 后的数据类型和case的数据类型需要一样 case后面可以有多个表达式和switch后的表达式匹配 在case语句中 输入fallthrough 可以穿透下一层 x.type()和x = interface{}和switch配合可以看到x空接口指向的类型   
	
	43、for index，val := range str    for index,val  range xxx 可以获得xxx字符串的内容及下标。  
	
	44、init函数在main函数前执行，每个函数都有一个init函数(初始化函数)  
	
	45、变量定义->init->main函数  
	
	46、匿名函数，一般调用一次，可以使用匿名函数，1、定义时，直接使用，只能调用一次  res := func (a int,b int)  int{xxxx}(a,b)。2、匿名函数赋给变量，调用变量可以使用函数   
	
	47、（在一个函数内）闭包是由函数和引用到的变量构成的，在这个闭包里，变量只声明一次，不会重复声明，重复调用闭包会重复更新数据 闭包相当于类   
	
	48、函数中的defer(延时机制） 在函数执行完毕后，快速释放所有资源。 defer 后面的语句，会进入一个单独的栈（先入后出）同时会将对应的变量数据同时拷贝进栈(深拷贝) 待函数内其他语句执行完后（return 后）【即函数执行完毕后再执行】，再从后往前一个个出栈，弹出对应语句。创建资源后，后面加上defer用于关闭资源， 可以在函数结束后再释放资源，函数内部的资源依然可以继续使用资源  
	
	49、值传递（深拷贝）基本数据类型：int，float，bool，string，数组，结构体，引用传递（浅拷贝）更快：指针，切片slice、map、管道chan，interface等都是引用类型    
	
	50、字符串常用函数：len(str)按字节算长度 r:=[]rune(str)解决有中文问题的字符串（再用len会变成按字符算长度）、nm，err = strconv.Atoi(str)字符串转整数，如果转换成功，err==nil、strconv.Itoa(int)整数转字符串、byt = []byte(str)转换字符为对应的ascci码，byte数组、string([]byte{97,98,99})将对应asscil转为对应的字符、strings.Contains("字符串","待查找字符")是否包含返回bool类型，strings.Count("字符串","字符")返回字符的数量，strings.EqualFold("字符串1","字符串2")不区分大小写比较、strings.Index("字符串","字符")查看对应字符下标、strings.LastIndex("字符串","字符")查看对应字符最后出现的下标、str = strings.Replace("字符串","被换字符","待换字符",n)，若n=-1，则全部替换，n为正整数，则替换n次、strings.Split("字符串","分隔符")按照分隔符进行分割，得到分割后的数据、strings.ToLow("字符串")小写转换、strings.ToUpper("字符串")大写转换、strings.HasPrefix("字符串","str")判断是不是以str开头、strings.HasSuffix("字符串","str")判断是不是以str结尾。  
	
	51、【time包 time.Time()查看当前时间】、【now = time.Now()获取的是结构体，now.Year().....使用】、【now.Format("2006-01-02 15:04:05")格式化标准输出当前时间，但是"2006-01-02 15:04:05"不可改变】  
	
	52、内置函数 len、nm = new("指针类型")分配类型，主要分配值类型，nm默认为0，new的两个作用，分配一个空间用来存储值，再分配一个空间用来存储指向值的指针  
	
	53、go中错误处理机制：defer、recover、panic  defer:=func(){err = recover()  if err!=nil{ fmt.Println(err)}} ()定义一个匿名函数，recover()会接受报错  
	
	54、err = errors.New("自定义错误")  panic(err) 如果出错，则终止返回自定义错误并退出  
	
	55、数组 var 数组名 [数组大小]类型；var 数组名 [大小]类型 = [大小]类型 <数据值>；var 数组名 = [大小]类型 {数据值}；var 数组名 = []类型 {数据值}；var 数组名 = [大小]类型{每个数组对应下标对应的数据值}  
	
	56、for index,value := range 数组 {在for循环语句中使用}   
	
	57、数组是相同类型的集合，大小确定后不能超出范围，不能动态变化    
	
	58、 随机生成，需要用到math下的rand包，需要先设置一个种子，rand.Seed(time.Now().UnixNano()) unix纳秒时间
	戳，然后再使用rand.Intn(最大范围)即可  
	
	59、切片：动态变化的数组，slice是数组的引用。var 切片名 []类型  []里不需要写大小，（引用类型，由三部分组成，头指针指向地址，长度，容量）  
	
	60、cap()查看容量，能存储的最大范围  
	
	61、切片的使用方式：1、定义一个切片，让切片引用指定数组。
	
	62、make创建切片，var xx []类型 = make([]类型，大小，容量)，对于切片，必须make后才能使用3、定义切片时，直接赋值，var xx []类型 = []类型 {数据值}  
	
	63、切片遍历和数组遍历一样都有for xxxx 和for-range遍历    
	
	64、切片可以用append进行动态追加，slice2 = append(slice2,待追加的数据)append后必须重新赋值，它并不改变自身数据，（先创建新的数组【将待添加的数据和原来的数据都加到新数组里】，然后再用新的切片引用） ,追加切片：name = append(name,name1...),只能追加切片，不能是数组，必须加上...  
	
	65、copy(切片1，切片2)，将切片2的数据拷贝给切片1，他们都是独立的空间，拷贝后互不影响，必须都是切片，切片2大于小于切片1的大小都不会报错，大的话，就只取切片1本身的长度得切片2   
	
	66、切片是引用类型，在函数实参传给形参时，对数据进行改变，原切片也会改变，因为是引用类型  
	
	67、字符串底层也是切片，但是和切片不同的是，str不可变，不能用str[0]="s"改变，切片可以改变，若想改变字符串，可以先转换为切片，然后改变数据后再转为字符串，arr = []byte(str),str = string(arr)【不能处理中文，byte按字节处理数据，而一个汉字占三个字节，所以不能处理中文】或者arr1 = []rune(str),str = string(arr1)【常用】  
	
	68、二维数组 var name [][]类型，先初始化再赋值，二维数组再内存里是每一行的头代表一个指针，指向这个数组；var name [][]类型 = [][]类型{{},{}} 二维数组的遍历也可以用for xxxx和for range  
	
	69、map是key-value类型，var name map[key类型]val类型  slice、map、function不可以作为key，不能用==比较  
	
	70、声明map是不会分配内存，只有make后才能赋值和使用   
	
	71、a = make(map[key类型]val类型,大小)，key一样的话会后来的会覆盖前面的，key不能重复，是map是无序排列的  
	
	72、先声明、再make：var a map[string]string  a = make(map[string]string,10)，或者声明时同时make :var a = make(map[string]string ,10)，或者声明时直接赋值:var a map[string]string = map[string]string{key:value,key1:value1}多层map后，里面的map也要make，每一个map都需要make  
	
	73、map的增加和修改，name[key] = value 即可  map的删除，delete(name,key) 删除，无论有无都不会报错；查找 val,ft = name[key],如果key存在，则ft为true，val为对应key的值；如果key不存在，则ft为false  
	
	74、map的遍历需要用for-range，for key，value range name{}  
	
	75、map切片，map个数动态增加；name := []map[string]string  
	
	76、sort.Ints(切片)对切片进行递增排序，map是引用类型数据，可以自动扩容，map的value经常用结构体表示会很方便        
	
	77、Type xxx struct{} 结构体 使用的时候 var name  xxx即可  
	
	78、结构体中指针、切片和map都需要make后才能使用，不make都是nil，结构体是值类型       
	
	79、struct创建类型 var name xxx;var name = xxx{};var name 指针xxx = new(xxx);var name 指针xxx = &xxx{}  
	
	80、struct间除了name外只有全部相同才能强转 变成不同的数据类型，不同数据类型不能相互赋值   
	
	81、struct可以加个tag标签 序列化struct 用来方便不同语音的交流、反引号json:字段名反引号   
	
	82、方法作用在数据类型上的，自定义类型都有方法  
	
	83、func (a A) test{} A是结构体，表明test绑定为A结构体的一个方法 test方法只能通过A类型变量调用，其他不能调用  
	
	84、func (xx type) method (形参类型) (返回值) {}   
	
	85、如果一个方法定义了string方法，在调用fmt.Println时会默认自动调用这个string方法   
	
	86、只有函数或方法是指针时才能调用指针类型，调用者会发生改变，否则结构体和函数都还是值拷贝。函数时，函数是值类型就只能传递值类型，是指针类型就只能传递指针，方法时，函数是值类型，无论传值或者地址都是值拷贝，传递的值类型，函数是指针类型，无论传值或地址都是引用拷贝，传递的指针类型。  
	
	87、 结构体淡化了指针和普通值，定义后，传递值和指针，编译器默认会加上指针的符号  
	
	88、封装：设置个Set和Get方法来存储和读取私有信息在不想对外公开的包中，给其他想引用的包流出接口  
	
	89、继承是通过在子结构体中加入 匿名的父结构体即可    
	
	90、接口：type xxx interface{ 方法.... }   接口里声明的方法不需要实现，不能使用变量，在其他结构体需要使用时，写出接口的方法，实现接口是指实现全部接口的方法。接口的实现是基于方法的，不需要指定实现哪个接口，只需要实现接口里的方法即可 interface是一个指针，是引用，使用时必须先初始化否则为nil         
	
	91、